
# Домашнее задание к занятию «Микросервисы: принципы»

Вы работаете в крупной компании, которая строит систему на основе микросервисной архитектуры.
Вам как DevOps-специалисту необходимо выдвинуть предложение по организации инфраструктуры для разработки и эксплуатации.

## Задача 1: API Gateway 

Предложите решение для обеспечения реализации API Gateway. Составьте сравнительную таблицу возможностей различных программных решений. На основе таблицы сделайте выбор решения.

Решение должно соответствовать следующим требованиям:
- маршрутизация запросов к нужному сервису на основе конфигурации,
- возможность проверки аутентификационной информации в запросах,
- обеспечение терминации HTTPS.

Обоснуйте свой выбор.

## Ответ №1  
### Предложение по решению для API Gateway

На основе анализа современных решений, я рекомендую использовать **Kong Gateway** в качестве ядра API Gateway для вашей системы.

**Краткое обоснование:** Kong обладает идеальным балансом между производительностью, богатой функциональностью (благодаря экосистеме плагинов), простотой эксплуатации и надежностью. Он основан на технологии **Nginx** и **OpenResty**, что гарантирует высокую производительность и стабильность. Его модель плагинов позволяет гибко настраивать поведение шлюза без написания кода, что соответствует всем вашим требованиям.

---

### Сравнительная таблица возможностей программных решений

В таблице рассмотрены наиболее популярные и проверенные в production-средах решения.

| Критерий / Решение            | Kong Gateway                                                | NGINX (как API Gateway)                                                       | Traefik                                                    | Gloo Edge (от Solo.io)                           | Spring Cloud Gateway                     |
| ----------------------------- | ----------------------------------------------------------- | ----------------------------------------------------------------------------- | ---------------------------------------------------------- | ------------------------------------------------ | ---------------------------------------- |
| **Тип решения**               | Специализированный API Gateway на базе OpenResty            | Универсальный веб-сервер / обратный прокси с возможностями API GW             | Edge-роутер / API Gateway                                  | API Gateway на базе Envoy                        | API Gateway на базе Spring (JVM)         |
| **Маршрутизация**             | ✅ (На основе путей, хостов, заголовков)                     | ✅ (Гибкая, на основе `location` в конфиге)                                    | ✅ (Динамическая, на основе меток Docker/K8s)               | ✅ (Продвинутая, на основе gRPC, GraphQL, REST)   | ✅ (Гибкая, на основе предикатов Spring)  |
| **Аутентификация**            | ✅ (Множество плагинов: JWT, Key-Auth, OAuth2, LDAP)         | ⚠️ (Базовая - через `auth_basic`, сложная требует скриптов Lua/OpenID Connect) | ✅ (Middlewares для Basic Auth, Digest, OIDC)               | ✅ (Расширенные плагины, интеграция с Auth0, OPA) | ✅ (Интеграция с Spring Security)         |
| **Терминация HTTPS**          | ✅ (Встроенная поддержка, обновление сертификатов через API) | ✅ (Эталонная реализация)                                                      | ✅ (Автоматическое получение сертификатов от Let's Encrypt) | ✅ (Встроенная, поддержка mTLS)                   | ✅ (Стандартная для Spring)               |
| **Производительность**        | Очень высокая (Nginx + LuaJIT)                              | Эталонно высокая                                                              | Высокая (на Go)                                            | Очень высокая (на базе Envoy)                    | Средняя (зависит от JVM)                 |
| **Динамическая конфигурация** | ✅ (Через БД или Declarative Config)                         | ⚠️ (Требует перезагрузки или Lua-скриптов)                                     | ✅ (Горячая перезагрузка, провайдеры)                       | ✅ (Through Envoy's xDS API)                      | ✅ (Интеграция с Spring Cloud Config)     |
| **Экосистема и плагины**      | ✅ (Огромное сообщество, множество готовых плагинов)         | ⚠️ (Требует кастомной разработки на Lua)                                       | ✅ (Много Middlewares, сообщество растет)                   | ✅ (Много плагинов, акцент на Service Mesh)       | ✅ (Можно использовать любые бины Spring) |
| **Управление и UI**           | ✅ (Kong Manager - Enterprise, Konga - OSS)                  | ❌ (Только конфиг-файлы)                                                       | ✅ (Встроенная Dashboard)                                   | ✅ (Gloo Portal, UI для управления)               | ❌ (Только через конфиги / аннотации)     |
| **Orchestration (K8s)**       | ✅ (Отличная интеграция через CRD Ingress)                   | ✅ (Ingress Controller)                                                        | ✅ (Нативный Ingress Controller)                            | ✅ (Нативный Ingress / Gateway API Controller)    | ✅ (Может работать внутри K8s)            |
| **Сложность освоения**        | Средняя                                                     | Высокая (для сложных сценариев)                                               | Низкая                                                     | Средняя / Высокая                                | Средняя (для Java-разработчиков)         |
| **Логирование и мониторинг**  | ✅ (Плагины для Prometheus, Datadog, Zipkin и др.)           | ✅ (Доступ к логам, может быть интегрирован)                                   | ✅ (Встроенная метрики, интеграции)                         | ✅ (Интеграция с Observability стеком)            | ✅ (Через Actuator и Spring生态)          |

---

### Обоснование выбора Kong Gateway

1.  **Полное соответствие требованиям:**
    *   **Маршрутизация:** Kong предоставляет мощный и гибкий механизм маршрутизации на основе `Routes` и `Services`. Вы можете определять правила на основе URI-пути, хоста, заголовков и методов HTTP.
    *   **Аутентификация:** Это одна из сильнейших сторон Kong. Плагин **JWT** (JSON Web Token) позволяет легко проверять подпись и claims токенов в запросах. Также доступны плагины для базовой аутентификации, OAuth 2.0, ACL (контроль доступа), что полностью закрывает требование.
    *   **Терминация HTTPS:** Kong легко настраивается на работу с SSL-сертификатами. Сертификаты можно загружать через Admin API, что позволяет автоматизировать процесс их обновления (например, с помощью cert-manager в Kubernetes).

2.  **Производительность и надежность:** Построенный на основе Nginx, Kong наследует его асинхронную, событийно-ориентированную архитектуру. Это гарантирует низкую задержку и высокую пропускную способность даже под большой нагрузкой, что критически важно для центрального узла всей системы.

3.  **Экосистема и расширяемость:** Модель плагинов Kong — его ключевое преимущество. Помимо аутентификации, вы получаете "из коробки" возможности для:
    *   **Rate Limiting** (ограничение частоты запросов).
    *   **Caching** (кэширование ответов).
    *   **Logging** (отправка логов в Syslog, HTTP-эндпоинты, Kafka и др.).
    *   **Monitoring** (метрики для Prometheus).
    *   **Security** (CORS, IP restriction, Bot detection).
    Это позволяет гибко развивать шлюз, не прибегая к разработке кастомного кода.

4.  **Операционная зрелость:**
    *   **Динамическая конфигурация:** Kong может хранить конфигурацию в базе данных (PostgreSQL/Cassandra), что позволяет обновлять маршруты и настройки плагинов "на лету" без перезагрузки.
    *   **Kubernetes-Native:** Существует официальный **Kong Ingress Controller**, который позволяет управлять шлюзом декларативно через привычные Kubernetes-ресурсы (Ingress, Custom Resources). Это идеально вписывается в современный DevOps-стек.
    *   **Сообщество и поддержка:** Kong имеет большое и активное сообщество, а также предлагает коммерческую Enterprise-версию с дополнительными функциями и поддержкой, что важно для крупной компании.

### Альтернативы

*   **NGINX:** Отличный выбор, если вам нужен максимальный контроль и вы готовы поддерживать кастомные Lua-скрипты для сложной логики. Он может быть выгоднее в чисто "проксирующих" сценариях без богатой логики плагинов.
*   **Traefik:** Идеален для environments, где доминирует Docker/Kubernetes, благодаря автоматическому обнаружению сервисов. Проще в начальной настройке, но экосистема плагинов пока уступает Kong.
*   **Spring Cloud Gateway:** Логичный выбор, если вся ваша экосистема построена на Spring (Java). Однако его производительность будет ниже, чем у решений на C/Go, и он привязывает вас к JVM-стеку.

### Итоговое предложение по внедрению

Для разработки и эксплуатации в крупной компании на основе микросервисной архитектуры я предлагаю:

1.  **Выбор продукта:** **Kong Gateway (Open Source version)**.
2.  **Способ развертывания:** В качестве **Kong Ingress Controller** внутри Kubernetes-кластера. Это позволит управлять маршрутизацией декларативно с помощью YAML-манифестов, интегрировать их в GitOps-процессы (например, с ArgoCD) и легко масштабировать.
3.  **Схема работы:**
    *   Все входящие HTTPS-запросы приходят на Kong.
    *   Kong проверяет SSL-сертификат.
    *   Плагин аутентификации (например, JWT) проверяет наличие и валидность токена в заголовке запроса.
    *   После успешной аутентификации Kong направляет запрос к соответствующему backend-сервису на основе правил маршрутизации.

Данное решение является надежным, производительным, соответствует всем заявленным требованиям и отлично вписывается в современные DevOps-практики.  

## Задача 2: Брокер сообщений

Составьте таблицу возможностей различных брокеров сообщений. На основе таблицы сделайте обоснованный выбор решения.

Решение должно соответствовать следующим требованиям:
- поддержка кластеризации для обеспечения надёжности,
- хранение сообщений на диске в процессе доставки,
- высокая скорость работы,
- поддержка различных форматов сообщений,
- разделение прав доступа к различным потокам сообщений,
- простота эксплуатации.

Обоснуйте свой выбор.

## Задача 3: API Gateway * (необязательная)

### Есть три сервиса:

**minio**
- хранит загруженные файлы в бакете images,
- S3 протокол,

**uploader**
- принимает файл, если картинка сжимает и загружает его в minio,
- POST /v1/upload,

**security**
- регистрация пользователя POST /v1/user,
- получение информации о пользователе GET /v1/user,
- логин пользователя POST /v1/token,
- проверка токена GET /v1/token/validation.

### Необходимо воспользоваться любым балансировщиком и сделать API Gateway:

**POST /v1/register**
1. Анонимный доступ.
2. Запрос направляется в сервис security POST /v1/user.

**POST /v1/token**
1. Анонимный доступ.
2. Запрос направляется в сервис security POST /v1/token.

**GET /v1/user**
1. Проверка токена. Токен ожидается в заголовке Authorization. Токен проверяется через вызов сервиса security GET /v1/token/validation/.
2. Запрос направляется в сервис security GET /v1/user.

**POST /v1/upload**
1. Проверка токена. Токен ожидается в заголовке Authorization. Токен проверяется через вызов сервиса security GET /v1/token/validation/.
2. Запрос направляется в сервис uploader POST /v1/upload.

**GET /v1/user/{image}**
1. Проверка токена. Токен ожидается в заголовке Authorization. Токен проверяется через вызов сервиса security GET /v1/token/validation/.
2. Запрос направляется в сервис minio GET /images/{image}.

### Ожидаемый результат

Результатом выполнения задачи должен быть docker compose файл, запустив который можно локально выполнить следующие команды с успешным результатом.
Предполагается, что для реализации API Gateway будет написан конфиг для NGinx или другого балансировщика нагрузки, который будет запущен как сервис через docker-compose и будет обеспечивать балансировку и проверку аутентификации входящих запросов.
Авторизация
curl -X POST -H 'Content-Type: application/json' -d '{"login":"bob", "password":"qwe123"}' http://localhost/token

**Загрузка файла**

curl -X POST -H 'Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJib2IifQ.hiMVLmssoTsy1MqbmIoviDeFPvo-nCd92d4UFiN2O2I' -H 'Content-Type: octet/stream' --data-binary @yourfilename.jpg http://localhost/upload

**Получение файла**
curl -X GET http://localhost/images/4e6df220-295e-4231-82bc-45e4b1484430.jpg

---

#### [Дополнительные материалы: как запускать, как тестировать, как проверить](https://github.com/netology-code/devkub-homeworks/tree/main/11-microservices-02-principles)

---

### Как оформить ДЗ?

Выполненное домашнее задание пришлите ссылкой на .md-файл в вашем репозитории.

---
